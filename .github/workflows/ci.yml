name: CI

on:
  push:
    branches: [main, next]
    paths-ignore:
      - "**.md"
      - "**.txt"
      - "manifest/**"
      - "docs/**"
  pull_request:
    types: [opened, reopened, synchronize, labeled, unlabeled]
    paths-ignore:
      - "**.md"
      - "**.txt"
      - "manifest/**"
      - "docs/**"
env:
  # Set the new value when the cache grows too much and we hit the runner's disk space limit
  # via https://github.com/rust-lang/docs.rs/pull/2433
  RUST_CACHE_KEY: rust-cache-20250701

jobs:
  lint:
    name: clippy
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: run clippy
        run: |
          rustup update --no-self-update stable
          rustup component add clippy
          make clippy

  rustfmt:
    name: rustfmt
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: run rustfmt
        run: |
          rustup update --no-self-update nightly
          rustup +nightly component add rustfmt
          make format-check
  build:
    name: build
    # Run this job after the linter, so the cache is hot
    needs: [lint]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: Swatinem/rust-cache@v2
        with:
          # Only update the cache on push onto the main branch. This strikes a nice balance between
          # cache hits and cache evictions (github has a 10GB cache limit).
          save-if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}

      - name: build
        run: |
          rustup update --no-self-update
          make build

  unit_tests:
    name: unit tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install rust
        run: |
          rustup update --no-self-update
          rustc --version

      - uses: taiki-e/install-action@nextest

      - uses: Swatinem/rust-cache@v2
        with:
          # Use a common cache for the basic compilation/formatter/clippy checks
          shared-key: ${{ github.workflow }}-shared
          prefix-key: ${{ env.RUST_CACHE_KEY }}
          save-if: ${{ github.ref == 'refs/heads/next' }}

      - name: Check tests
        # We run `cargo check` to verify that the workspace compiles correctly before attempting
        # to execute the tests from each crate. This produces easier to read output if a compilation
        # error occurs
        run: cargo check --tests

      - name: Run tests
        run: make test

  define-matrix:
    runs-on: ubuntu-latest

    outputs:
      integration_tests_list: ${{ steps.integration_tests_list.outputs.integration_tests_list }}

    steps:
      - uses: actions/checkout@v4

      - name: Define integration list
        id: integration_tests_list
        # This shell script looks for all functions named 'integration' and groups them in an array like, comma separated format.
        # e.g.: ["integration_install_stable","integration_update_stable","integration_update_specific_component","integration_rollback_specific_component"]
        # NOTE: This is by no means bulletproof, but as long as only testing functions are named 'integration*', this should work
        run: |
          list=$(find -H . -name '*.rs' -exec grep 'fn integration' {} +  | tr -d '()[]{}' | awk 'BEGIN { print "integration_tests_list=[" } {print "\"" $NF "\","} END { print "]" }' | tr -d '\n' | sed 's/,\]/\]/')
          echo "$list" >> "$GITHUB_OUTPUT"
          echo "$list"

  integration_test:
    name: integration tests
    # We only want to run the integration tests if the unit tests pass, and that has the added
    # benefit that we can re-use the cache from the unit test job for all integration tests
    needs: [define-matrix, unit_tests]
    runs-on: ubuntu-latest
    if: ${{ github.ref_name == 'main' || contains(github.event.pull_request.labels.*.name, 'check:install') }}
    strategy:
      matrix:
        integration_test: ${{ fromJSON(needs.define-matrix.outputs.integration_tests_list) }}

    steps:
      - uses: actions/checkout@v4

      - name: Install rust
        run: |
          rustup update --no-self-update
          rustc --version

      - uses: taiki-e/install-action@nextest

      - uses: Swatinem/rust-cache@v2
        with:
          # Use a common cache for the basic compilation/formatter/clippy checks
          shared-key: ${{ github.workflow }}-shared
          prefix-key: ${{ env.RUST_CACHE_KEY }}
          save-if: false

      - name: Check tests
        # We run `cargo check` to verify that the workspace compiles correctly before attempting
        # to execute the tests from each crate. This produces easier to read output if a compilation
        # error occurs
        run: cargo check --tests

      - name: run tests
        run: cargo nextest run ${{ matrix.integration_test }}
