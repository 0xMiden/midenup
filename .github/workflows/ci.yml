name: CI

on:
  push:
    branches: [main, next]
    paths-ignore:
      - "**.md"
      - "**.txt"
      - "manifest/**"
      - "docs/**"
  pull_request:
    types: [opened, reopened, synchronize, labeled, unlabeled]
    paths-ignore:
      - "**.md"
      - "**.txt"
      - "manifest/**"
      - "docs/**"
env:
  # Set the new value when the cache grows too much and we hit the runner's disk space limit
  # via https://github.com/rust-lang/docs.rs/pull/2433
  RUST_CACHE_KEY: rust-cache-20250701

jobs:
  lint:
    name: clippy
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: run clippy
        run: |
          rustup update --no-self-update stable
          rustup component add clippy
          make clippy

  rustfmt:
    name: rustfmt
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: run rustfmt
        run: |
          rustup update --no-self-update nightly
          rustup +nightly component add rustfmt
          make format-check
  build:
    name: build
    # Run this job after the linter, so the cache is hot
    needs: [lint]
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: Swatinem/rust-cache@v2
        with:
          # Only update the cache on push onto the main branch. This strikes a nice balance between
          # cache hits and cache evictions (github has a 10GB cache limit).
          save-if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}

      - name: build
        run: |
          rustup update --no-self-update
          make build

  unit_tests:
    name: unit tests
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install rust
        run: |
          rustup update --no-self-update
          rustc --version

      - uses: taiki-e/install-action@nextest

      - uses: Swatinem/rust-cache@v2
        with:
          # Use a common cache for the basic compilation/formatter/clippy checks
          shared-key: ${{ github.workflow }}-shared
          prefix-key: ${{ env.RUST_CACHE_KEY }}
          save-if: ${{ github.ref == 'refs/heads/next' }}

      - name: Check tests
        # We run `cargo check` to verify that the workspace compiles correctly before attempting
        # to execute the tests from each crate. This produces easier to read output if a compilation
        # error occurs
        run: cargo check --tests

      - name: Run tests
        run: make test

  integration_test:
    # These tests will
    name: integration tests
    # We only want to run the integration tests if the unit tests pass, and that has the added
    # benefit that we can re-use the cache from the unit test job for all integration tests
    needs: [unit_tests]
    runs-on: ubuntu-latest
    if: ${{ github.ref_name == 'main' || contains(github.event.pull_request.labels.*.name, 'check:install') }}
    steps:
      - uses: actions/checkout@v4

      - name: Install rust
        run: |
          rustup update --no-self-update
          rustc --version

      - uses: taiki-e/install-action@nextest

      - uses: Swatinem/rust-cache@v2
        with:
          # Use a common cache for the basic compilation/formatter/clippy checks
          shared-key: ${{ github.workflow }}-shared
          prefix-key: ${{ env.RUST_CACHE_KEY }}
          save-if: false

      - name: Bypass rustup's cargo, use the cargo executable directly
        run: |
          echo "$(rustc --print sysroot)/bin":"${GITHUB_PATH}" > "${GITHUB_PATH}"

      - name: Check tests
        # We run `cargo check` to verify that the workspace compiles correctly before attempting
        # to execute the tests from each crate. This produces easier to read output if a compilation
        # error occurs
        run: cargo check --tests

      - name: run tests
        run: make integration-test
