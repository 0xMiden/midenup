use std::process::Command;

fn main() {
    // Generated by cargo at runtime when the build script is run:
    // https://doc.rust-lang.org/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts
    let build_script = std::env::var("OUT_DIR").unwrap();

    write_command_to_file(&["cargo", "--version"], &(build_script.clone() + "/cargo_version.in"));
    write_command_to_file(
        &["git", "rev-parse", "--verify", "HEAD"],
        &(build_script + "/git_revision.in"),
    );
}

fn write_command_to_file(command: &[&str], file: &str) {
    let full_command =
        command.iter().fold(String::new(), |acc, argument| format!("{acc} {argument}"));

    let output = {
        let command =
            Command::new(command.first().expect("command must have at leaste one element"))
                .args(command.iter().skip(1))
                .output()
                .unwrap_or_else(|err| {
                    panic!("Couldn't run {full_command} because of: {err}");
                })
                .stdout;

        String::from_utf8(command).unwrap_or_else(|err| {
            panic!("failed to parse {full_command} output as string, because of {err}")
        })
    };

    std::fs::write(file, output.trim())
        .unwrap_or_else(|err| panic!("Failed to write to {file}: {err}"));
}
