use std::io::Write;

use anyhow::{Context, bail};

use crate::{
    Config,
    channel::{Channel, ChannelType, Component},
    version::Authority,
};

/// Installs a specified toolchain by channel or version.
pub fn install(config: &Config, channel_type: &ChannelType) -> anyhow::Result<()> {
    let Some(channel) = config.manifest.get_channel(channel_type) else {
        bail!("channel '{}' doesn't exist or is unavailable", channel_type);
    };

    config.ensure_midenup_home_exists()?;

    let toolchain_dir = config
        .midenup_home
        .join("toolchains")
        .join(format!("{}", &channel.name));

    if toolchain_dir.exists() {
        bail!("the '{}' toolchain is already installed", &channel.name);
    }

    std::fs::create_dir_all(&toolchain_dir).with_context(|| {
        format!(
            "failed to create toolchain directory: '{}'",
            toolchain_dir.display()
        )
    })?;

    // Create install script
    let install_file_path = toolchain_dir.join("install").with_extension("rs");
    let mut install_file = std::fs::File::create(&install_file_path).with_context(|| {
        format!(
            "failed to create file for install script at '{}'",
            install_file_path.display()
        )
    })?;

    let install_script_contents = generate_install_script(channel);
    install_file
        .write_all(&install_script_contents.into_bytes())
        .with_context(|| {
            format!(
                "failed to write install script at '{}'",
                install_file_path.display()
            )
        })?;

    let mut child = std::process::Command::new("cargo")
        .env("MIDEN_SYSROOT", &toolchain_dir)
        // HACK(pauls): This is for the benefit of the compiler, until it moves to using
        // MIDEN_SYSROOT instead.
        .env("MIDENC_SYSROOT", &toolchain_dir)
        .args(["+nightly", "-Zscript"])
        .arg(&install_file_path)
        .stderr(std::process::Stdio::inherit())
        .stdout(std::process::Stdio::inherit())
        .spawn()
        .context("error occurred while running install script")?;

    child
        .wait()
        .context("failed to execute toolchain installer")?;

    Ok(())
}

fn generate_install_script(channel: &Channel) -> String {
    let stdlib = channel
        .get_component("std")
        .expect("Miden standard library is a required component, but isn't available");
    let base = channel
        .get_component("base")
        .expect("Miden transation kernel library is a required component, but isn't available");
    let vm = channel
        .get_component("vm")
        .expect("Miden VM is a required component, but isn't available");
    let cargo_miden = channel
        .get_component("cargo-miden")
        .expect("The cargo-miden extension is a required component, but isn't available");

    let mut repos = String::with_capacity(1024);
    for (i, component) in [stdlib, base].into_iter().enumerate() {
        if i > 0 {
            repos.push('\n');
        }
        format_component_as_cargo_dependency(&mut repos, component);
    }

    let mut install_commands = String::with_capacity(1024);
    for component in [vm, cargo_miden] {
        format_component_cargo_install_command(&mut install_commands, component);
    }

    format!(
        "#!/usr/bin/env cargo
---cargo
[dependencies]
{repos}
---

// NOTE: This file was generated by midenup. Do not edit by hand

use std::process::Command;

fn main() {{
    // MIDEN_SYSROOT is set by `midenup` when invoking this script, and will contain the resolved
    // (and prepared) sysroot path to which this script will install the desired toolchain
    // components.
    let miden_sysroot_dir = std::path::Path::new(env!(\"MIDEN_SYSROOT\"));
    let lib_dir = miden_sysroot_dir.join(\"lib\");

    // Write transaction kernel to $MIDEN_SYSROOT/lib/base.masp
    let tx = miden_lib::MidenLib::default();
    tx.as_ref()
      .write_to_file(lib_dir.join(\"base\").with_extension(\"masp\"))
      .expect(\"failed to install Miden transaction kernel library component\");

    // Write stdlib to $MIDEN_SYSROOT/std.masp
    let stdlib = miden_stdlib::StdLibrary::default();
    stdlib
        .as_ref()
        .write_to_file(lib_dir.join(\"std\").with_extension(\"masp\"))
        .expect(\"failed to install Miden standard library component\");

{install_commands}
}}
"
    )
}

fn format_component_as_cargo_dependency(buf: &mut String, component: &Component) {
    use core::fmt::Write;

    match &component.version {
        Authority::Cargo { package, version } => {
            let package = package.as_deref().unwrap_or(component.name.as_ref());
            write!(buf, "{package} = \"{version}\"").unwrap();
        }
        Authority::Git(repo) => write!(
            buf,
            "{} = {{ version = \"> 0.0.0\", git = \"{repo}\" }}",
            &component.name
        )
        .unwrap(),
        Authority::Path(path) => write!(
            buf,
            "{} = {{ version = \"> 0.0.0\", path = \"{}\" }}",
            &component.name,
            path.display()
        )
        .unwrap(),
    }
}

fn format_component_cargo_install_command(buf: &mut String, component: &Component) {
    use core::fmt::Write;

    writeln!(buf, r#"    // Install {}\n"#, &component.name).unwrap();
    buf.push_str("    let mut child = Command::new(\"cargo\")\n");
    buf.push_str("        .arg(\"install\")\n");

    // Install the component via `cargo` according to its versioning authority
    match &component.version {
        Authority::Cargo { package, version } => {
            let package = package.as_deref().unwrap_or(component.name.as_ref());
            writeln!(buf, "        .arg(\"{package}\")\n").unwrap();
            writeln!(buf, "        .args([\"--version\", \"{version}\"])\n").unwrap();
        }
        Authority::Git(repo_uri) => {
            writeln!(buf, "        .args([\"--git\", \"{repo_uri}\"])\n").unwrap();
        }
        Authority::Path(path) => {
            writeln!(buf, "        .args([\"--path\", \"{}\"])\n", path.display()).unwrap();
        }
    }

    // Enable optional features, if present
    if !component.features.is_empty() {
        let features = component.features.join(",");
        writeln!(buf, "        .args([\"--features\", \"{features}\"])\n").unwrap();
    }

    // Force the install target directory to be $MIDEN_SYSROOT/bin
    writeln!(buf, "        .arg(\"--root\")\n").unwrap();
    writeln!(buf, "        .arg(&miden_sysroot_dir)\n").unwrap();

    // Spawn command
    writeln!(buf, "        .stderr(std::process::Stdio::inherit())\n").unwrap();
    writeln!(buf, "        .stdout(std::process::Stdio::inherit())\n").unwrap();
    writeln!(buf, "        .spawn()\n").unwrap();
    writeln!(
        buf,
        "        .expect(\"failed to install component '{}'\");\n",
        &component.name
    )
    .unwrap();

    // Await results
    writeln!(
        buf,
        "    child.wait().expect(\"failed to install component '{}'\");\n",
        &component.name
    )
    .unwrap();
}
