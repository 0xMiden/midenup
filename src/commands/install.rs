use std::io::Write;

use anyhow::{Context, bail};

use crate::{
    Config,
    channel::{Channel, ChannelType},
    version::Authority,
};

/// Installs a specified toolchain by channel or version.
pub fn install(config: &Config, channel_type: &ChannelType) -> anyhow::Result<()> {
    let Some(channel) = config.manifest.get_channel(channel_type) else {
        bail!("channel '{}' doesn't exist or is unavailable", channel_type);
    };

    config.ensure_midenup_home_exists()?;

    let toolchain_dir = config.midenup_home.join("toolchains").join(format!("{}", &channel.name));

    if toolchain_dir.exists() {
        bail!("the '{}' toolchain is already installed", &channel.name);
    }

    std::fs::create_dir_all(&toolchain_dir).with_context(|| {
        format!("failed to create toolchain directory: '{}'", toolchain_dir.display())
    })?;

    // Create install script
    let install_file_path = toolchain_dir.join("install").with_extension("rs");
    let mut install_file = std::fs::File::create(&install_file_path).with_context(|| {
        format!("failed to create file for install script at '{}'", install_file_path.display())
    })?;

    let install_script_contents = generate_install_script(channel);
    install_file.write_all(&install_script_contents.into_bytes()).with_context(|| {
        format!("failed to write install script at '{}'", install_file_path.display())
    })?;

    let mut child = std::process::Command::new("cargo")
        .env("MIDEN_SYSROOT", &toolchain_dir)
        // HACK(pauls): This is for the benefit of the compiler, until it moves to using
        // MIDEN_SYSROOT instead.
        .env("MIDENC_SYSROOT", &toolchain_dir)
        .args(["+nightly", "-Zscript"])
        .arg(&install_file_path)
        .stderr(std::process::Stdio::inherit())
        .stdout(std::process::Stdio::inherit())
        .spawn()
        .context("error occurred while running install script")?;

    child.wait().context("failed to execute toolchain installer")?;

    Ok(())
}

fn generate_install_script(channel: &Channel) -> String {
    // Prepare install script template
    let engine = upon::Engine::new();
    let template = engine
        .compile(
            r#"#!/usr/bin/env cargo
---cargo
[dependencies]
{%- for dep in dependencies %}
{{ dep.package }} = { version = "{{ dep.version }}"
{%- if dep.git_uri %}, git = "{{ dep.uri }}"
{%- else if dep.path %}, path = "{{ dep.path }}"
{%- endif %} }
{%- endfor %}
---

// NOTE: This file was generated by midenup. Do not edit by hand

use std::process::Command;

fn main() {
    // MIDEN_SYSROOT is set by `midenup` when invoking this script, and will contain the resolved
    // (and prepared) sysroot path to which this script will install the desired toolchain
    // components.
    let miden_sysroot_dir = std::path::Path::new(env!("MIDEN_SYSROOT"));
    let lib_dir = miden_sysroot_dir.join("lib");

    // Write transaction kernel to $MIDEN_SYSROOT/lib/base.masp
    let tx = miden_lib::MidenLib::default();
    tx.as_ref()
        .write_to_file(lib_dir.join("base").with_extension("masp"))
        .expect("failed to install Miden transaction kernel library component");

    // Write stdlib to $MIDEN_SYSROOT/std.masp
    let stdlib = miden_stdlib::StdLibrary::default();
    stdlib
        .as_ref()
        .write_to_file(lib_dir.join("std").with_extension("masp"))
        .expect("failed to install Miden standard library component");

    {% for component in installable_components %}
    // Install {{ component.name }}
    let mut child = Command::new("cargo")
        .arg(
          "{{ component.required_toolchain }}",
        )
        .arg("install")
        .args([
        {%- for arg in component.args %}
          "{{ arg }}",
        {%- endfor %}
        ])
        // Force the install target directory to be $MIDEN_SYSROOT/bin
        .arg("--root")
        .arg(&miden_sysroot_dir)
        // Spawn command
        .stderr(std::process::Stdio::inherit())
        .stdout(std::process::Stdio::inherit())
        .spawn()
        .expect("failed to install component '{{ component.name }}'");

    // Await results
    child.wait().expect("failed to install component '{{ component.name }}'");

    {% endfor %}
}
"#,
        )
        .unwrap_or_else(|err| panic!("invalid install script template: {err}"));

    // Prepare install script context with available channel components
    let stdlib = channel
        .get_component("std")
        .expect("Miden standard library is a required component, but isn't available");
    let base = channel
        .get_component("base")
        .expect("Miden transation kernel library is a required component, but isn't available");
    let vm = channel
        .get_component("vm")
        .expect("Miden VM is a required component, but isn't available");
    let cargo_miden = channel
        .get_component("cargo-miden")
        .expect("The cargo-miden extension is a required component, but isn't available");

    // The set of cargo dependencies needed for the install script
    let dependencies = [stdlib, base]
        .into_iter()
        .map(|component| match &component.version {
            Authority::Cargo { package, version } => {
                let package = package.as_deref().unwrap_or(component.name.as_ref()).to_string();
                upon::value! {
                    package: package,
                    version: version.to_string(),
                    git_uri: "",
                    path: "",
                }
            },
            Authority::Git(uri) => {
                upon::value! {
                    package: component.name.clone(),
                    version: "> 0.0.0",
                    git_uri: uri.clone(),
                    path: "",
                }
            },
            Authority::Path(path) => {
                upon::value! {
                    package: component.name.clone(),
                    version: "> 0.0.0",
                    git_uri: "",
                    path: path.display().to_string(),
                }
            },
        })
        .collect::<Vec<_>>();

    // The set of components to be installed with `cargo install`
    let installable_components = [vm, cargo_miden]
        .into_iter()
        .map(|component| {
            let mut args = vec![];
            match &component.version {
                Authority::Cargo { package, version } => {
                    let package = package.as_deref().unwrap_or(component.name.as_ref());
                    args.push(package.to_string());
                    args.push("--version".to_string());
                    args.push(version.to_string());
                },
                Authority::Git(repo_uri) => {
                    args.push("--git".to_string());
                    args.push(repo_uri.clone());
                },
                Authority::Path(path) => {
                    args.push("--path".to_string());
                    args.push(path.display().to_string());
                },
            }

            let required_toolchain =
                component.rustup_channel.clone().unwrap_or(String::from("+stable"));

            // Enable optional features, if present
            if !component.features.is_empty() {
                let features = component.features.join(",");
                args.push("--features".to_string());
                args.push(features);
            };

            upon::value! {
                name: component.name.to_string(),
                required_toolchain: required_toolchain,
                args: args,
            }
        })
        .collect::<Vec<_>>();

    // Render the install script
    template
        .render(
            &engine,
            upon::value! {
                dependencies: dependencies,
                installable_components: installable_components,
            },
        )
        .to_string()
        .unwrap_or_else(|err| panic!("install script rendering failed: {err}"))
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::manifest::Manifest;

    #[test]
    fn install_script_template_from_local_manifest() {
        let manifest = Manifest::load_from("file://manifest/channel-manifest.json").unwrap();

        let stable = manifest.get_channel(&ChannelType::Stable).unwrap();

        let script = generate_install_script(stable);

        println!("{script}");

        assert!(script.contains("// Install cargo-miden"));
    }
}
